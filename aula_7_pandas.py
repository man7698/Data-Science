# -*- coding: utf-8 -*-
"""Aula_7_pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/storopoli/ciencia-de-dados/blob/master/notebooks/Aula_7_pandas.ipynb

[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/storopoli/ciencia-de-dados/master?filepath=notebooks%2FAula_7_pandas.ipynb)
<br>
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/storopoli/ciencia-de-dados/blob/master/notebooks/Aula_7_pandas.ipynb)

# `pandas`

**Objetivos**: Apresentar a biblioteca pandas, importação de dados, DataFrame e funções aritméticas.

## Dados Tabulares

* Primeira linha: Cabeçalho (*Header*)
* Cada coluna: uma variável
* Cada linha: uma observação
* Cada Tabela/arquivo: um nível de observação

![dados-tabulares](https://github.com/storopoli/ciencia-de-dados/blob/master/notebooks/images/dados-tabulares.png?raw=1)

## Documentação do `pandas`

https://pandas.pydata.org/pandas-docs/stable/
"""

import pandas as pd

"""## Elementos do `pandas`

* *DataFrame*: Tabela Retangular de Dados
    - Conjunto de *Series*
    - Todas compartilhando o mesmo índice (*index*)
* *Series*: Coluna do *DataFrame*
    - *arrays* em 1-D
    - Composta por:
        - Sequência de Valores
            - *numeric*
            - *string*
            - *bool*
        - Sequencia de *index*

![pandas-df](https://github.com/storopoli/ciencia-de-dados/blob/master/notebooks/images/pandas-df.svg?raw=1)

| Pandas dtype    | Python type    | NumPy type                                | Uso                                                   |
|-----------------|----------------|-------------------------------------------|-------------------------------------------------------|
| `object`        | `str` ou misto | *string_*, *unicode_*, misto              | Texto ou misto de valores `numeric` and `non-numeric` |
| `int64`         | `int`          | *int_*, `int8`, `int16`, `int32`, `int64` | Número Inteiros                                       |
| `float64`       | `float`        | *float_*, `float16`, `float32`, `float64` | Número Reais                                          |
| `bool`          | `bool`         | `bool`                                    | Verdadeiro ou Falso                                   |
| `datetime64`    | NA             | `datetime64[ns]`                          | Data e Hora                                           |
| `timedelta[ns]` | NA             | NA                                        | Diferença entre duas `datetimes`                      |
| `category`      | NA             | NA                                        | Lista Finita de Valores em Texto                      |

## Importando Dados no `pandas`

![pandas-io](https://github.com/storopoli/ciencia-de-dados/blob/master/notebooks/images/pandas-io.svg?raw=1)

| Formato   | Input                 | Output            | Observação                     |
| --------- | --------------------- | ----------------- | ------------------------------ |
| CSV       | `pd.read_csv()`       | `.to_csv()`       | Arquivo Texto CSV, TSV, etc    |
| XLS/XLSX  | `pd.read_excel()`     | `.to_excel()`     | Planilha                       |
| HDF       | `pd.read_hdf`()       | `.to_hdf()`       | HDF5 database                  |
| SQL       | `pd.read_sql()`       | `.to_sql()`       | SQL table                      |
| JSON      | `pd.read_json()`      | `.to_json()`      | JavaScript Object Notation     |
| MSGPACK   | `pd.read_msgpack()`   | `.to_msgpack()`   | Portable binary format         |
| HTML      | `pd.read_html()`      | `.to_html()`      | código HTML                    |
| GBQ       | `pd.read_gbq()`       | `.to_gbq()`       | Google Big Query format        |
| DTA       | `pd.read_stata()`     | `.to_stata()`     | Stata                          |
| Parquet   | `pd.read_parquet()`   | `.to_parquet()`   | Apache Parquet                 |
| Feather   | `pd.read_feather()`   | `.to_feather()`   | Apache Feather                 |
| Qualquer  | `pd.read_clipboard()` | `.to_clipboard()` | Ex., de pág HTML               |
| Qualquer  | `pd.read_pickle()`    | `.to_pickle()`    | (Structured) Python object     |

## Importando `CSV`

Se atentar com os seguintes argumentos de [`pd.read_csv()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html):

* Caminho (`path`)
* `sep`: `','`, para europeu/brasileiro use `';'`
* `decimal`: `'.'`, para europeu/brasileiro use `','`
* `header`: `pandas` tenta adivinhar
* `index_col`: `None`, mas pode ser uma coluna do arquivo (ex: 2ª coluna use `index_col=2`)
* `names`: `None`, mas pode ser uma lista dos nomes das variáveis (colunas)
* `skip_rows`: `None` (pular linhas)
* `na_values`: `None`, mas pode ser qualquer string (ex: `'NA'`)
* `thousands`: `None` mas pode ser `','` ou `'.'`
* `encoding`
    - `'utf8'`: padrão
    - `'latin1'`: ç à é î ã

## Importando Planilhas `Excel`

Se atentar com os seguintes argumentos de [`pd.read_excel()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html):
* Caminho (`path`)
* `sheet_name`: `0`, mas pode ser qualquer `string` ou `int`
    - `sheet_name=0`: Primeira aba da planilha
    - `sheet_name=2`: Terceira aba da planilha
    - `sheet_name='Plan1'`: Primeira aba da planilha
    - `sheet_name='nome_que_usuário_colocou'`

## Exportando dados

* `CSV`: [`.to_csv()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_csv.html)
* `Excel`: [`.to_excel()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_excel.html)

## Corona Vírus

A [Kaggle](https://www.kaggle.com) possui um dataset de Coronavirus. 

Clique [aqui](https://www.kaggle.com/sudalairajkumar/novel-corona-virus-2019-dataset#covid_19_data.csv) para saber mais.

Vamos usar a versão de **28 de Agosto de 2020**.
"""

corona = pd.read_csv('data/covid_19_data.csv', index_col=0)

"""## Inspecionando o *DataFrame*"""

type(corona)

corona.info()

corona.shape

corona.columns

corona.head()
#corona.head(3)

corona.tail()
#corona.tail(3)

"""## Removendo Entradas

Usando o [`pd.drop()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html), se atentar com os argumentos:
* `axis`: `0` para linhas `1` para colunas
* `inplace`: `True` altera o *DataFrame* atual

Vamos fazer uma análise global então removeremos as províncias/estados (coluna `Province/State`)
"""

corona.drop(['Province/State'], axis=1, inplace=True)  # True ele altera o DF
corona.head()
#corona = pd.read_csv('data/covid_19_data.csv', index_col=0)

"""## Lidando com dados faltantes (*missing values* `NA`)

| Method         | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| `df.dropna()`  | Filtra `NA`, selecionar linhas (`axis = 0`) ou selecionar colunas (`axis=1`) |
| `df.fillna()`  | Preencher os `NA` com algum valor  |
| `df.isnull()`  | Retorna os valores booleanos indicando quais valores são `NA` |
"""

corona.dropna(axis=0).head()

corona.isnull()

corona.fillna(0, inplace=True)
corona.head()

"""## Selecionando e Filtrando

* `DataFrame['Coluna']` = retorna uma *Series*
* `DataFrame[['Coluna']]` = retorna um *DataFrame*
* `DataFrame[['Coluna_1, 'Coluna_2']]` = multíplas Colunas
* `DataFrame.query()`

Tanto para *DataFrame* quanto para *Series*

* `.loc[]`
* `.iloc[]`
* `.where()`
"""

# retornando uma Series
corona['Country/Region']

# retornando um DataFrame
corona[['Country/Region']]

corona[['Country/Region', 'Confirmed']]
# corona['Country/Region', 'Confirmed']  # Gera um erro

# retornando uma linha (observação) com base em um índice
corona.loc[10694] #index
#corona.index

# retornando uma linha (observação) com base em um índice
corona.iloc[10694] #localização

# Filtrando e Retornando um DataFrame
corona[corona['Confirmed'] >8e4]  # 8e4 é 8 com 4 zeros = 80,000

# Filtrando variáveis qualitativas
corona[corona['Country/Region'] == 'Brazil']

# Filtrando e Retornando um DataFrame
corona[(corona['Confirmed'] > 8e4) & (corona['Recovered'] > 1000)]

# Filtrando e Retornando um DataFrame com .loc
corona.loc[(corona['Confirmed'].between(8e4, 10e4, inclusive=False)) &
           (corona['Recovered'].between(12e3, 20e3, inclusive=True))]

# Filtrando e Retornando um DataFrame com df.where()
corona.where(corona['Confirmed'] > 10e2)
# Obs: se atente com os NaN

# Filtrando e Retornando um DataFrame com df.query()
corona.query('Confirmed > 8e4')

# Filtrando e Retornando um DataFrame com df.query()
corona.query('Confirmed > 8e4 & 10e3 < Recovered < 12e3')

"""## Fatiando

* `DataFrame['Coluna']` = retorna uma *Series*
* `DataFrame[['Coluna']]` = retorna um *DataFrame*
* `DataFrame[['Coluna_1, 'Coluna_2']]` = multíplas Colunas

Tanto para *DataFrame* quanto para *Series*

* `.loc[]`
* `.iloc[]`
"""

# Fatiando com loc[]
corona.loc[100:200]

# Fatiando com loc[]
corona.loc[100:200, 'Country/Region':'Confirmed']

# Fatiando com iloc[]
corona.iloc[100:200, :3]

# Criando um subset com algumas variáveis (lista)
variaveis = ['Country/Region', 'Confirmed', 'Deaths']
corona[variaveis]

"""## Criando Novas Variáveis"""

corona['Confirmed + Deaths'] = corona['Confirmed'] + corona['Deaths']
corona.head(3)

corona['Death by Cases'] = corona['Deaths'] / corona['Confirmed']
corona.head(3)

"""## `pandas` `pd.cut()` e `pd.qcut()`

* `pd.cut()`: ordena valores em *bins* (faixas de valores)
    - `bins=x`: quantidade de faixas de valores desejada 
* `pd.qcut()`: mesma coisa que `pd.cut()` mas usa *quantis*
    - `q=x`: quantidade de quantis
        * 3: tercis
        * 4: quantis
        * 5: quintis
        * 10: decis
"""

# 4 faixas (Quantis)
pd.cut(corona['Confirmed'],bins=4)

# 3 (Tercis)
pd.cut(corona['Confirmed'], 3)

"""## Convertendo Valores

* `.to_numeric()`
* `.to_datetime()`
* `.astype()`
    - `'bool'`
    - `'int64'`
    - `'float64'`
    - `'str'`
    - `'category'`
* `.replace()`
"""

corona['Country/Region'].replace('Mainland China', 'China', inplace=True)

corona.head(3)

corona.info()

corona['Last Update'] = pd.to_datetime(corona['Last Update'])

corona.info()

"""## Removendo duplicados

* `.unique()`: retorna valores únicos
* `.duplicated()`: retorna `bool` para linhas duplicadas
* `drop_duplicates()`: retorna *DataFrame* com linhas duplicadas removidas
"""

# Quantos países?
len(corona['Country/Region'].unique())

# Quantos Duplicados?
sum(corona.duplicated(subset=['Country/Region']))

corona.drop_duplicates(subset=['Country/Region'], keep='last', inplace=True)
corona.head(3)
#Obs: se atente ao index

corona.info()

"""## Ordenando e Rankeando

* `.sort_index()`
* `.sort_values()`: ordena de acordo com uma coluna
* `.rank()`: computa ranks numéricos ($1$ à $n$)
"""

corona.sort_values(by=['Recovered'], ascending=False).head(5)

"""## Países

A [Kaggle](https://www.kaggle.com) possui um dataset de Países.

Clique [aqui](https://www.kaggle.com/fernandol/countries-of-the-world) para saber mais.
"""

paises = pd.read_csv('data/countries of the world.csv')
paises.head()

"""## Alguma coisa errada

`Dtype` das colunas numéricas aparece como `object` quando deveria ser `float`
"""

paises.info()

paises = pd.read_csv('data/countries of the world.csv', decimal=',')
paises.head()

paises.info()

"""## Variáveis Qualitativas

* `.astype('category')`
* `pd.get_dummies()`
"""

paises['Region'] = paises['Region'].astype('category')
paises.info()

pd.get_dummies(paises['Region'], prefix='REGION')

paises_dummies = pd.concat([paises, pd.get_dummies(paises['Region'], prefix='REGION')],
                           axis=1).drop(['Region'],axis=1)
paises_dummies.head()

"""## Outra coisa errada

`Country` Estados Unidos aparece como `United States` e o nosso dataset `corona` aparece como `US`. Corrigir com o `pd.replace`
"""

paises.loc[paises['Country'] == 'United States']

paises['Country'].replace('United States', 'US', inplace=True)

"""## `pandas` - `join()`

| Opção    | Comportamento                                                                       |
| -------- | ----------------------------------------------------------------------------------- |
| `inner`  | Usa somente as combinações de chaves (*keys*) observadas em ambos *DataFrames*      |
| `left`   | Usa todas as combinações de chaves (*keys*) encontradas no *DataFrames* da esquerda |
| `right`  | Usa todas as combinações de chaves (*keys*) encontradas no *DataFrames* da direita  |
| `output` | Usa todas as combinações de chaves (*keys*) observadas em ambos *DataFrames* juntos |

![pandas-join](http://www.datasciencemadesimple.com/wp-content/uploads/2017/09/join-or-merge-in-python-pandas-1.png)
"""

corona = corona.merge(paises, how='left', left_on='Country/Region', right_on='Country')

corona.tail()

corona.info()

"""## Salvar o dataset limpo

Para usar no futuro
"""

corona.to_csv('data/corona_limpo.csv', index=None)

"""# Atividade

Importar o arquivo `data/mtcars.csv`. É uma base de dados extraída da revista americana sobre carros *Motor Trend US* de 1974. Possui 32 carros(linhas) e 11 características (colunas)

## Características
* `mpg`: Milhas por Galão (consumo)
* `cyl`: Número de cilíndros
* `disp`: Cilindada (em polegada cúbica)
* `hp`: Cavalos de Potência (HP)
* `drat`: Relação do eixo traseiro
* `wt`:	Peso em (1,000 libras)
* `qsec`: Tempo que atinge 400m (1/4 de milha)
* `vs`: Motor (0 = Forma em V, 1 = Reto)
* `am`: Transmissão (0 = Automático, 1 = Manual)
* `gear`: Número de marchas
* `carb`: Número de carburadores

## Importar os dados

Use o `pd.read_csv()` para importar os dados, use o argumento `index_col=0` para que a primmeira coluna (modelo) seja os índices do *DataFrame*
"""

import pandas as pd

mtcars = pd.read_csv()

"""Inspeciona o *DataFrame* com `.info()` e veja se todas as variáveis possuem os valores apropriados. Também verifique se você possui dados faltantes (missing, `NA`, `NaN`).

## Ordenando

Use o `.sort_values()` para ordenar o dataset descrescente em cavalos de potência (`hp`). Se atente ao **descrescente**

Qual o carro com mais HP? Ele está muito mais a frente do segundo colocado?
"""

mtcars.sort_values().head()

"""## Filtrando

1. Crie um *DataFrame* somente com os carros automáticos e use o `.shape` e veja quantos carros são dentre os 32
2. Crie um *DataFrame* somente com os carros que possuem motor em forma de V e use o `.shape` e veja quantos carros são dentre os 32
"""

# am - Transmissão (0 = Automático, 1 = Manual)

# vs - Motor (0 = Forma em V, 1 = Reto)

"""## Selecionando aleatoriamente uma amostra do `mtcars`

1. Leia a documentação do [`pd.sample()`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sample.html)
2. Use o `.sample()` para selecionar aleatoriamente uma amostra de 10 carros. Se atente ao argumento `replace`.
"""

