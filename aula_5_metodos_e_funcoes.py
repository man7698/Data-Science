# -*- coding: utf-8 -*-
"""Aula_5_Metodos_e_Funcoes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/storopoli/ciencia-de-dados/blob/master/notebooks/Aula_5_Metodos_e_Funcoes.ipynb

[![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/storopoli/ciencia-de-dados/master?filepath=notebooks%2FAula_5_Metodos_e_Funcoes.ipynb)
<br>
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/storopoli/ciencia-de-dados/blob/master/notebooks/Aula_5_Metodos_e_Funcoes.ipynb)

# Funções e métodos

**Objetivos**: Apresentar as funções e métodos de Python

Uma das técnicas de programação existentes consiste em quebrar um problema maior em vários problemas menores (ou sub-problemas). Desta forma cada sub-problema é solucionado e ao final teremos a solução de nosso problema maior. 

Em programação, para atendermos tal necessidade, existem funções e métodos. Funções seguem os princípios da programação procedural e e os métodos estão diretamente relacionados com programação orientada a objetos.

Python trabalha tanto com funções como também com métodos.

## Funções
Uma função é um bloco de programa contendo início e fim e identificado por um nome, por meio do qual será referenciado em qualquer parte do programa principal ou em outra função.

A característica principal de uma função é que há retorno de valor ou variável para o programa para o qual fez a chamada a função. Quando uma função é chamada por um programa, ela é executada até o seu término e a execução do programa volta exatamente para a primeira linha de instrução, após a linha que fez a chamada da função.

```python
def <nome da função>(<argumento_1>,<argumento_2>, ..., <argumento_n>):
    <instruções a serem executadas pela função>
```

```python
def <nome da função> (<argumento_1>,<argumento_2>, ..., <argumento_n>):
    <instruções a serem executadas pela função>
    return <valor a ser retornado pela função>
```

### Exemplo
"""

def foo():
    print("foo")

def servico_restaurante(valor):
    """Adiciona 10% ao final de um valor"""
    valor *= 1.10
    print(f"Com serviço de 10%: R${valor}")
    return valor

servico_restaurante(82)

"""## Atividade Função #1

Fazer uma função chamada `potencia` que tem dois argumentos:
* argumento `numero`: um numero real `float` ou inteiro `int`
* argumento `potencia`: um numero real `float` ou inteiro `int`

Ela deve retornar o argumento `numero` elevado ao argumento `potencia`
"""

def potencia(numero, potencia):
    assert isinstance(numero, int) or isinstance(numero, float)
    assert isinstance(potencia, int) or isinstance(potencia, float)
    return $$$$

assert potencia(2, 3) == 8
assert potencia(2, 3.6) == 12.125732532083186

potencia(5, 2)

def funcao(arg1, arg2):
    print(arg1)
    print(arg2)

"""## Atividade Função #2

Lembram-se que o módulo de um número inteiro pode determinar se ele é *ímpar* ou *par*?

```python
15 % 2    # 1
14 % 2    # 0
```

Fazer uma função chamada `numero_par` que tem um argumento:
* argumento `numero`: um numero inteiro `int`

Ela deve testar se o número é par e retorna um `bool` `True` ou `False`
"""

def numero_par(numero):
    assert isinstance(numero, int)
    $$$$
    return $$$

assert numero_par(2) == True
assert numero_par(3) == False

numero_par(15)

"""## Métodos

Python nos permite que programemos utilizando orientação a objetos. E neste paradigma de programação temos que o equivalente a função, de forma bem simplista, são os métodos.

No paradigma de orientação a objetos temos que uma classe é formada por dados (atributos) e operações (métodos) numa só estrutura. Um objeto é uma instância de uma classe.

### Exemplo

`__init__` é o método construtor da classe e faz alocação de recursos necessários ao funcionamento do objeto além da definição inicial dos atributos do objeto. Ele é executado quando da criação do objeto.

Note que todos os métodos têm como primeiro parâmetro o `self`. Todo método em Python é obrigado a ter este paramêtro e por padronização adotou-se a palavra `self` (padrão PEP-8) que faz referência ao próprio objeto que está sendo criado e/ou manipulado.
"""

class aluno:
    def __init__(self, matricula, nome, curso, nota_1, nota_2):
        self.matricula = matricula
        self.nome = nome
        self.curso = curso
        self.nota_1 = nota_1
        self.nota_2 = nota_2
        self.media = (nota_1 + nota_2) / 2
    
    def getMatricula (self):
        return self.matricula
    
    def getNome (self):
        return self.nome
    
    def getCurso (self):
        return self.curso
    
    def getNota (self, bimestre = 1):
        if bimestre == 1:
            return self.nota_1
        elif bimestre == 2:
            return self.nota_2
    
    def getMedia (self):
        return self.media

aluno1 = aluno(1, "Fernanda", "ciências da computação", 8.6, 7)
aluno2 = aluno(2, "Luiza", "sistemas de informação", 4.5, 5.2)

print(aluno1.getNome())
print(aluno2.getNota())

aluno1.getMatricula()